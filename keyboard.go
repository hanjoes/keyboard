package keyboard

import (
	"os"
	"os/exec"
	"os/signal"
	"syscall"
)

// Keyboard represents a virtual keyboard.
type Keyboard struct {
	In       chan Keystroke
	Consumed chan bool
}

// Keystroke contains data generated by one key press.
type Keystroke struct {
	Input []byte
}

// NewKeyboard constructs a new keyboard.
func NewKeyboard(debug bool) Keyboard {
	return Keyboard{make(chan Keystroke, 1), make(chan bool, 1)}
}

// Start to listen to the input.
func (kb *Keyboard) Start() {
	initFlags()

	sigio := make(chan os.Signal, 1)
	signal.Notify(sigio, syscall.SIGIO)

	in, err := syscall.Open("/dev/tty", syscall.O_RDONLY, 0)
	if err != nil {
		panic(err)
	}

	_, err = fcntl(in, syscall.F_SETFL, syscall.O_ASYNC|syscall.O_NONBLOCK)
	if err != nil {
		panic(err)
	}

	buf := make([]byte, 128)
	for {
		select {
		case <-sigio:
			for {
				n, err := syscall.Read(in, buf)
				if err == syscall.EAGAIN || err == syscall.EWOULDBLOCK {
					break
				}
				select {
				case kb.In <- Keystroke{buf[:n]}:
				}
			}
		}
	}
}

// Shutdown must be called or tty will be left in
// the status we used for this keyboard.
func (kb *Keyboard) Shutdown() {
	resetTTY()
}

//////////////////////

func fcntl(fd int, cmd int, arg int) (val int, err error) {
	r, _, e := syscall.Syscall(syscall.SYS_FCNTL, uintptr(fd), uintptr(cmd), uintptr(arg))
	val = int(r)
	if e != 0 {
		err = e
	}
	return
}

func initFlags() {
	stty("-icanon", "-echo", "-isig")
}

func resetTTY() {
	stty("sane")
}

func stty(flags ...string) {
	cmd := exec.Command("stty", flags...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	err := cmd.Run()
	if err != nil {
		panic(err)
	}
}
